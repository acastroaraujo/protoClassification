---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# protoClassification

<!-- badges: start -->
[![R-CMD-check](https://github.com/acastroaraujo/protoClassification/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/acastroaraujo/protoClassification/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

You can install the development version of protoClassification from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("acastroaraujo/protoClassification")
```

```{r overview, echo=FALSE}
knitr::include_graphics("overview.png")
```

### Get Started

To simulate a dataset like the one in the Figure you need to create to decide a couple of things first.

1. The number of $K$ dimensions.
2. The marginal probabilities for each dimension.
3. A correlation matrix for the dimensions.

```{r}
library(protoClassification)
set.seed(1)
K <- 6 # 1st step
marginals <- rbeta(K, 2, 2) # 2nd step
rho <- rlkjcorr(1, K, eta = 1) # 3rd step

nms <- paste0("k", 1:K)
names(marginals) <- nms
dimnames(rho) <- list(nms, nms)

round(rho, 2)
round(marginals, 2)
```

**Generate data.**

```{r}
set.seed(1)
X <- make_binary_data(marginals, rho, obs = 1e3)
head(X, n = 10)
```

Verify that the column means _roughly_ correspond to the marginal probabilities.

```{r}
colMeans(X) |> round(2)
```

In order to verify that the data follows the correlation structure in `rho` you would have to calculate a "[tetrachoric correlation](https://en.wikipedia.org/wiki/Polychoric_correlation)."

```{r, warning=FALSE}
psych::tetrachoric(X)$rho |> round(2)
```

Additional stuff for Prototype Classification Model:

- `g` (gamma) sensitivity parameter
- `w` a vector of attention weights for each k
- `P` a list of prototypes

```{r}
set.seed(1)
w <- runif(K)
w <- w / sum(w)
g <- 10
```

Calculate distance and similarity for one prototype at a time:

```{r}
d <- calculateDistSim(
  P = rep(1, K), 
  w = w, 
  data = X, 
  g = g
)

str(d)
```

Calculate distance, similarity, and probabilities for multiple prototypes at the same time:

```{r}
prototypes <- list(
  P1 = rep(1, K),
  P2 = rep(0, K),
  P3 = rep(1:0, K / 2)
)

out <- compute(prototypes, w, X, g = 10, r = 1)
out
```

`consolidate()` the previous output into a single data frame:

```{r}
d <- consolidate(out)
str(d)
```

